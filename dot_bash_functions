#!/bin/bash


# Create a new directory and enter it
md() {
	echo "Usage: md <directory_name>"
	mkdir -p "$@" && cd "$@"
}

# Find shorthand
f() {
	echo "Usage: f <filename>"
	find . -name "$1" 2>&1 | grep -v 'Permission denied'
}

# cd into whatever is the forefront Finder window
cdf() {
	echo "Usage: cdf"
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')" || exit
}

# Use `which` along with symlink resolving
whichlink() {
	echo "Usage: whichlink <command>"
	$(type -p greadlink readlink | head -1) -f $(which $@)
}

# git commit browser, needs fzf. Ctrl-m to view commit.
log() {
	echo "Usage: log"
	git log --graph --color=always \
		--format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
	fzf --ansi --no-sort --reverse --tiebreak=index --toggle-sort=\` \
		--bind "ctrl-m:execute:
			echo '{}' | grep -o '[a-f0-9]\{7\}' | head -1 |
			xargs -I % sh -c 'git show --color=always % | less -R'"
}

# Make two beeps
beep() {
	echo "Usage: beep"
	echo -e '\a'; sleep 0.1; echo -e '\a';
}

# Start an HTTP server from a directory, optionally specifying the port
server() {
	echo "Usage: server [port]"
	local port="${1:-8011}"
	open "http://localhost:${port}/" &
	statikk --port "$port" .
}

# Copy with progress
cp_p() {
	echo "Usage: cp_p <source> <destination>"
	rsync -WavP --human-readable --progress $1 $2
}

# Get gzipped size
gz() {
	echo "Usage: gz <file>"
	echo "orig size    (bytes): "
	cat "$1" | wc -c
	echo "gzipped size (bytes): "
	gzip -c "$1" | wc -c
}

# Whois a domain or a URL
whois() {
	echo "Usage: whois <domain_or_url>"
	local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
	if [ -z $domain ] ; then
		domain=$1
	fi
	echo "Getting whois record for: $domain â€¦"
	/usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}

# Preview CSV files
csvpreview() {
	echo "Usage: csvpreview <file>"
	sed 's/,,/, ,/g;s/,,/, ,/g' "$@" | column -s, -t | less -#2 -N -S
}

# Extract archives
extract() {
	echo "Usage: extract <file>"
	if [ -f "$1" ] ; then
		local filename=$(basename "$1")
		local foldername="${filename%%.*}"
		local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
		local didfolderexist=false
		if [ -d "$foldername" ]; then
			didfolderexist=true
			read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
			echo
			if [[ $REPLY =~ ^[Nn]$ ]]; then
				return
			fi
		fi
		mkdir -p "$foldername" && cd "$foldername"
		case $1 in
			*.tar.bz2) tar xjf "$fullpath" ;;
			*.tar.gz) tar xzf "$fullpath" ;;
			*.tar.xz) tar Jxvf "$fullpath" ;;
			*.tar.Z) tar xzf "$fullpath" ;;
			*.tar) tar xf "$fullpath" ;;
			*.taz) tar xzf "$fullpath" ;;
			*.tb2) tar xjf "$fullpath" ;;
			*.tbz) tar xjf "$fullpath" ;;
			*.tbz2) tar xjf "$fullpath" ;;
			*.tgz) tar xzf "$fullpath" ;;
			*.txz) tar Jxvf "$fullpath" ;;
			*.zip) unzip "$fullpath" ;;
			*) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
		esac
	else
		echo "'$1' is not a valid file"
	fi
}

# Check who is using the laptop's iSight camera
camerausedby() {
	echo "Usage: camerausedby"
	echo "Checking to see who is using the iSight cameraâ€¦ ðŸ“·"
	usedby=$(lsof | grep -w "AppleCamera\|USBVDC\|iSight" | awk '{printf $2"\n"}' | xargs ps)
	echo -e "Recent camera uses:\n$usedby"
}

# Create animated GIFs from any video
gifify() {
	echo "Usage: gifify <input_movie.mov> [--good]"
	if [[ -n "$1" ]]; then
		if [[ $2 == '--good' ]]; then
			ffmpeg -i "$1" -r 10 -vcodec png out-static-%05d.png
			time convert -verbose +dither -layers Optimize -resize 900x900\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > "$1.gif"
			rm -f out-static*.png
		else
			ffmpeg -i "$1" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$1.gif"
		fi
	else
		echo "Proper usage: gifify <input_movie.mov>. You DO need to include extension."
	fi
}

# Turn that video into webm
webmify() {
	echo "Usage: webmify <input_movie>"
	ffmpeg -i "$1" -vcodec libvpx -acodec libvorbis -isync -copyts -aq 80 -threads 3 -qmax 30 -y "$1.webm"
}

# Direct it all to /dev/null
nullify() {
	echo "Usage: nullify <command>"
	"$@" >/dev/null 2>&1
}

# Convert file to data URI
todatauri() {
	echo "Usage: todatauri <file>"
	local M=$(file "$1" --mime-type | sed 's/^.*: //')
	local D=$(openssl base64 -in "$1" | tr -d '\n')
	echo "data:$M;base64,$D"
}

# Lazy initialize nvm
nvm() {
	echo "Usage: nvm <command>"
	unset -f nvm
	export NVM_DIR="$HOME/.nvm"
	. "$NVM_DIR/nvm.sh" --no-use
	nvm "${@}"
}

# Lazy initialize conda
conda() {
	echo "Usage: conda <command>"
	unset -f conda
	source <(/opt/miniconda3/bin/conda shell.bash hook)
	conda "${@}"
}

# Function to manage proxy settings
proxy() {
	if [ $# -eq 0 ]; then
        echo "Usage: proxy <set|unset|test> [port]"
        return 1
    fi
	local hostip localip
	hostip=$(ip route show | grep -i default | awk '{ print $3}')
	localip=$(hostname -I | awk '{print $1}')
	local default_port=4780
	local port=${2:-$default_port}
	local PROXY_HTTP="http://${hostip}:${port}"

	set_proxy() {
		export http_proxy="${PROXY_HTTP}"
		export HTTP_PROXY="${PROXY_HTTP}"
		export https_proxy="${PROXY_HTTP}"
		export HTTPS_PROXY="${PROXY_HTTP}"
		git config --global http.proxy "${PROXY_HTTP}"
		git config --global https.proxy "${PROXY_HTTP}"

		test_setting
	}

	unset_proxy() {
		unset http_proxy
		unset HTTP_PROXY
		unset https_proxy
		unset HTTPS_PROXY
		git config --global --unset http.proxy
		git config --global --unset https.proxy

		test_setting
	}

	test_setting() {
		echo "Host ip: . . . . . . . ${hostip}"
		echo "Local ip:. . . . . . . ${localip}"
		echo "Current proxy: . . . . ${https_proxy}"
	}

	case "$1" in
		set)
			set_proxy ;;
		unset)
			unset_proxy ;;
		test)
			test_setting ;;
		*)
			echo "Unsupported arguments. Usage: proxy <set|unset|test> [port]" ;;
	esac
}
